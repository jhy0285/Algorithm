---
title: 프로그래머스 운영체제 (LV3)[PCCP 모의고사1]
date: 2024-05-08
categories: [알고리즘, 프로그래머스]
tags: [Python,Algorithm,Programmers]
pin : false
---
## 문제
[프로그래머스 운영체제](https://school.programmers.co.kr/learn/courses/15008/15008-pccp-%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC-1%ED%9A%8C)

개발자 준모는 운영체제를 만들었습니다. 준모가 만든 운영체제는 프로그램의 우선순위와 호출된 시각에 따라 실행 순서를 결정합니다. 모든 프로그램에는 1부터 10까지의 점수가 매겨져 있으며, 이 점수가 낮을수록 우선순위가 높은 프로그램입니다. 각 프로그램들은 실행 시간이 정해져 있으며 프로그램이 호출되면 대기상태에 있다가 자신의 순서가 되면 실행 시간 동안 실행된 뒤 종료됩니다.

준모가 만든 운영체제는 호출된 프로그램들 중 우선순위가 가장 높은 프로그램을 먼저 실행합니다. 호출된 각 프로그램은 자신보다 우선순위가 높은 호출된 프로그램이 모두 종료된 후에 실행됩니다. 단, 실행 중인 프로그램보다 우선순위가 높은 프로그램이 호출되어도 실행 중이던 프로그램은 중단되지 않고 종료될 때까지 계속 실행됩니다. 또한, 우선순위가 같은 프로그램들 중에서는 먼저 호출된 프로그램이 먼저 실행됩니다.

다음은 1번부터 4번까지의 4개의 프로그램이 호출된 예시입니다.

<div align='center'>
    <img src="../assets/img/programmers/운영체제/problem.png"  height="200px">
</div>

예를 들어, 1번부터 4번까지 4개의 프로그램의 점수가 순서대로 2, 1, 3, 3이며, 호출된 시각은 0, 5, 5, 12초이고, 수행시간은 10, 5, 3, 2라고 가정해 봅시다.

1. 1번 프로그램이 0초에 호출될 때 실행 중인 프로그램이 없으므로, 0초에 1번 프로그램이 바로 실행됩니다. 1번 프로그램은 10초에 종료되며, 2, 3번 프로그램이 새로 호출됩니다. <br><br>
2. 호출된 2, 3번 프로그램 중 2번 프로그램의 점수가 1로 우선순위가 높습니다. 2번 프로그램은 5초에 실행되어 10초에 종료될 때까지 5초 동안 대기했습니다. 2번 프로그램은 15초에 종료되며, 4번 프로그램이 새로 호출됩니다.<br><br>
3. 호출된 3, 4번 프로그램은 점수가 같지만, 3번 프로그램이 먼저 호출되었기 때문에 3번 프로그램이 먼저 실행됩니다. 3번 프로그램은 5초에 호출되어 15초에 실행될 때까지 10초 동안 대기했습니다. 3번 프로그램은 18초에 종료됩니다.<br><br>
4. 4번 프로그램이 마지막으로 실행되며, 4번 프로그램은 12초에 실행되어 18초에 종료될 때까지 6초 동안 대기했습니다. 4번 프로그램은 20초에 종료됩니다.

모든 프로그램이 종료되는 시각은 20초이며, 각 프로그램에 대기한 시간은 순서대로 0, 5, 10, 6초입니다. 점수가 1인 프로그램의 대기시간 합은 5초, 점수가 3인 프로그램의 대기시간 합은 16초 임을 알 수 있습니다.

프로그램들의 정보를 나타내는 2차원 정수 배열 `program`이 주어질 때, 모든 프로그램들이 종료되는 시각과 프로그램의 점수마다 대기시간의 합을 정수 배열에 담아 return 하는 solution 함수를 완성하세요.

return 해야 하는 `answer` 배열은 길이가 11인 정수 배열입니다. `answer[0]`은 모든 프로그램들이 종료되는 시각을 의미하며, `answer[i]`(1 ≤ i ≤ 10)는 프로그램의 점수가 i인 프로그램들의 대기시간의 합을 의미합니다.

## 제한사항

- 1 ≤ `program` 의 길이 ≤ 100,000
- `program[i]` 은 i+1번 프로그램의 정보를 의미하며, `[a, b, c]`의 형태로 주어집니다.
  - a는 프로그램의 점수를 의미하며, 1 ≤ a ≤ 10 을 만족합니다.
  - b는 프로그램이 호출된 시각을 의미하며, 0 ≤ b ≤ 10,000,000을 만족합니다.
  - c는 프로그램의 실행 시간을 의미하며, 1 ≤ c ≤ 1,000을 만족합니다.
  - a, b쌍이 중복되는 프로그램은 입력으로 주어지지 않습니다. 즉, 호출된 시각이 같으면서 점수도 같은 프로그램은 없습니다.


## 입출력 예


| program                          | result(answer)                        |
|----------------------------------|---------------------------------------|
| [[2, 0, 10], [1, 5, 5], [3, 5, 3], [3, 12, 2]] | [20, 5, 0, 16, 0, 0, 0, 0, 0, 0, 0] |
| [[3, 6, 4], [4, 2, 5], [1, 0, 5], [5, 0, 5]]   | [19, 0, 0, 4, 3, 14, 0, 0, 0, 0, 0] |



## 입출력 예 설명

입출력 예 #1
- 문제 예시와 같습니다.

입출력 예 #2
- 그림으로 나타내면 아래 그림과 같습니다.

<div align='center'>
    <img src="../assets/img/programmers/운영체제/input.png"  height="200px">
</div>

## 풀이

```python

# 대기중 딕셔너리 key: 자기 번호 , value : 우선순위, 대기시작 시간
#  딕셔너리중 가

# 일단 숫자들은 1~10 까지 있고
#출력은 최종 종료시간, 숫자 1부터 10까지의 각 대기시간을 한 리스트에출력

#입력은 [[2, 0, 10], [1, 5, 5], [3, 5, 3], [3, 12, 2]]  첫번쨰는 숫자, 두번째는 호출되는시각, 세번쨰는 수행되는거 걸리는시간

# 입력 길이는 10만개

def solution(program):
    answer_list=[0 for i in range(11)]
    program.sort(key=lambda x: (x[1],x[0]))
    print(program)
    waiting=[]
    now=program.pop()
    call=now[1]
    finish=now[2]
    #wating이 기준이면 풀리겠네
    while program:
        #기다리고 있는게 존재하면
        if waiting:
            # waiting에서 우선순위에 따라 뺴고
            wait=waiting.pop()
            #대기시간 계산해서
            wait_time=finish-wait[1]
            #정답에 추가하고
            answer_list[wait[0]]+=wait_time
            #finish를 갱신한다
            finish+=wait[2]


            #그런다음 남은 program중에서 waiting에 넣을껄 구한다.
            # 남은  program중 finish보다 전에 호출되는 모든 일들은
            while program[0][1] <=finish:
                # waiting에 추가한다.
                waiting.append(program.pop())
                # 다시 waiting을 탐색하기 위해 되돌아 간다.
                continue

        #여기까지왔다는 것은 1. 현재
        while waiting:
            # waiting에서 우선순위에 따라 뺴고
            wait = waiting.pop()
            # 대기시간 계산해서
            wait_time = finish - wait[1]
            # 정답에 추가하고
            answer_list[wait[0]] += wait_time
            # finish를 갱신한다
            finish += wait[2]


        # 이제 다시 제일 첫번째 값을 다시 기준으로 삼아서 위 과정을 반복한다.
        #근데이제, 여기서 waitining
        else :
            start=compared[1]
            end=compared[2]
        #지금 now에 시작되고 끝나기까지 호출되는게 없다면 => 호출된것들, 즉 waiting들을 정리해서 실행시키면됨
        #waiting의 우선순위는 1. 점수 2. 우선 호출 1,2 같다면 암거나 해도될듯
        # waiting중에서 우선순위따라 하나를 골라서 => 개를 다시 now로 하고 비교해야될듯
        else:
            waiting.sort(key=lambda x: (x[0], x[1]))
            wait_now=waiting.pop()
            start=end
            end=end+wait_now[2]

    # start_time=4
    # end_time=start_time+pg[2]
    #이사이에 pg[1]이 존재하는 모든 애들을 가져와야하나?
    # wait_list[]


    answer = []

    return answer


program = [[2, 0, 10], [1, 5, 5], [3, 5, 3], [3, 12, 2]]
program2=[[3, 6, 4], [4, 2, 5], [1, 0, 5], [5, 0, 5]]
solution(program2)
```

## 설명
처음에는 우선순위를 커스텀해서 **우선순위 큐를 이용하면 되겠다고 생각**했다.

그러나 잘 생각해보면 굳이 커스텀할 필요 없이, **파이썬에서 제공되는 heapq를 사용하면 빠르게 구현이 가능**했다.

우선 **파이썬의 heapq는 최소힙으로 구현한 우선순위 큐**로서 사용가능하고,

그 기준은 iterable한 객체일 경우, **첫번쨰 인덱스의 값부터 시작해서 마지막 인덱스의 값까지 비교**하는데,

각 **인덱스 값의 오름차순으로 우선순위**가 높다.

즉 [0,2,3] 과 [0,2,5] 일 경우, 첫번쨰 값과 두번쨰 값은 각각 0, 2로 동일하지만,

세번쨰 값이 3이 5보다 작으므로 [0,2,3]이 우선순위가 더 높으므로 pop을 할경우 해당 값이 나온다.

이 문제에 경우, 대기하고 있는 프로그램의 우선순위는 다음과 같다.

1. [번호, 호출시각, 걸리는시간] 중 **번호가 낮은게 첫번쨰 기준**
2. [번호, 호출시각, 걸리는시간] 중 번호가 서로 같다면, 먼저 호출된, 즉 **호출시각이 낮은게(빠른게) 두번쨰 기준**

따라서, 아무런 **우선순위 커스텀 없이 바로 heapq의 내장 우선순위 로직을 이용**하면 된다.

그리고 번호, 호출시각이 모두 같은 프로그램은 존재하지 않으므로 이 이상 고민할 필요가 없다.

그 밖에 자잘한 엣지 케이스(프로그램이 1개만 있을경우, 프로그램 끝나고 난뒤 한참뒤에  다음 프로그램이 실행될 경우 등등)들은

위에 코드에 **주석을 보면 어떻게 처리했는지 이해** 할수 있을 것이다.


## 문제에서 얻은 것

처음에는 heapq의 우선순위가 커스텀이 필요하다고 생각하여

어떻게 하면 직관적이고 간단하게 구현 할수 있을지 찾아보았다.



```python
# 파이썬에서 단순 값들의 오름차순, 내림차순 우선순위 커스텀이 필요할 경우, 가장 직관적이고 간단한 방법
import heapq

#원본 데이터
data = [[2, 0, 10],[5, 0, 10], [1, 5, 5], [3, 5, 3], [3, 12, 2]]

#우선순위 기준을 커스텀한 튜플을 만들기 위해 새로운 리스트 생성
custom_priority_data = [(-item[2], -item[0], item[1], item) for item in data]

#heapify를 사용하여 커스텀 우선순위 큐 생성
heapq.heapify(custom_priority_data)

#우선순위 큐에서 요소를 하나씩 꺼내 출력
while custom_priority_data:
    print(heapq.heappop(custom_priority_data)[3])


#이 경우 우선순위는 다음과 같다
# 1. 리스트의 세번째 값을 내림차순으로 => 즉 큰 값이 더 우선됨
# 2. 그다음 리스트의 첫번쨰 값을 내림차순으로 => 즉 큰 값이 더 우선됨
# 3. 그다음 리스트의 두번쨰 값을 오름차순으로 => 즉 작은 값이 더 우선됨
```

따라서 출력은 아래와 같이 나온다.

```python
[5, 0, 10]
[2, 0, 10]
[1, 5, 5]
[3, 5, 3]
[3, 12, 2]
```


